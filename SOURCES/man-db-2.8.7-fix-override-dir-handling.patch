From c73e7dd16b7915ac9c67a376e014ea1220095348 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Tue, 27 Aug 2019 17:53:03 +0200
Subject: [PATCH] man(1): Fix override dir handling
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Previously, override dir was affecting only some cases
of manpath determination.

Apply it only when all paths has been gathered instead.
(Depending on the definition of when the override dir applies,
this might not be correct).

Also look for override dir when sorting candidates.

Fixes src/tests/man-9 failing when --with-override-dir=od
is passed to ./configure.

Reported-by: Nikola Forró <nforro@redhat.com>
Tested-by: Nikola Forró <nforro@redhat.com>
---
 src/man.c  | 33 ++++++++++++++++++++++++++++++++
 src/manp.c | 55 +++++++++++++++++++++---------------------------------
 2 files changed, 54 insertions(+), 34 deletions(-)

diff --git a/src/man.c b/src/man.c
index 6d1cba7..b3d13d1 100644
--- a/src/man.c
+++ b/src/man.c
@@ -2712,6 +2712,32 @@ static bool duplicate_candidates (struct candidate *left,
 	return ret;
 }
 
+static int cand1_differs_by_override_dir (const struct candidate *left,
+		                          const struct candidate *right)
+{
+	size_t ov_len, pre_ov_len;
+
+	ov_len = strlen (OVERRIDE_DIR);
+	if (!ov_len)
+		return 0;
+
+	if (!STREQ (left->source->name, right->source->name))
+		return 0;
+
+	pre_ov_len = strlen(right->path);
+	if (!STRNEQ (left->path, right->path, pre_ov_len))
+		return 0;
+
+	if (left->path[pre_ov_len] != '/')
+		return 0;
+	pre_ov_len++;
+
+	if (STREQ (left->path + pre_ov_len, OVERRIDE_DIR))
+		return 1;
+
+	return 0;
+}
+
 static int compare_candidates (const struct candidate *left,
 			       const struct candidate *right)
 {
@@ -2801,6 +2827,13 @@ static int compare_candidates (const struct candidate *left,
 	if (cmp)
 		return cmp;
 
+	/* Sort override dir first
+	 */
+	if (cand1_differs_by_override_dir(left, right))
+		return -1;
+	if (cand1_differs_by_override_dir(right, left))
+		return 1;
+
 	/* Try comparing based on language. We used to prefer to display a
 	 * page in the user's preferred language than a page from a better
 	 * section, but that attracted objections, so now we prefer to get
diff --git a/src/manp.c b/src/manp.c
index 5441339..e437183 100644
--- a/src/manp.c
+++ b/src/manp.c
@@ -903,23 +903,6 @@ static char *def_path (enum config_flag flag)
 	return manpath;
 }
 
-/*
- * If specified with configure, append OVERRIDE_DIR to dir param and add it
- * to list.
- */
-static void insert_override_dir (gl_list_t list, const char *dir)
-{
-	char *override_dir = NULL;
-
-	if (!strlen (OVERRIDE_DIR))
-		return;
-
-	if ((override_dir = xasprintf ("%s/%s", dir, OVERRIDE_DIR))) {
-		add_dir_to_list (list, override_dir);
-		free (override_dir);
-	}
-}
-
 /*
  * For each directory in the user's path, see if it is one of the
  * directories listed in the man_db.config file.  If so, and it is
@@ -968,7 +951,6 @@ char *get_manpath_from_path (const char *path, int mandatory)
 			if (!manpath_map_found)
 				debug ("is in the config file\n");
 			manpath_map_found = true;
-			insert_override_dir (tmplist, config_item->cont);
 			add_dir_to_list (tmplist, config_item->cont);
 		} GL_LIST_FOREACH_END (config);
 
@@ -989,11 +971,8 @@ char *get_manpath_from_path (const char *path, int mandatory)
 		debug ("adding mandatory man directories\n");
 
 		GL_LIST_FOREACH_START (config, config_item) {
-			if (config_item->flag == MANDATORY) {
-				insert_override_dir (tmplist,
-						     config_item->key);
+			if (config_item->flag == MANDATORY)
 				add_dir_to_list (tmplist, config_item->key);
-			}
 		} GL_LIST_FOREACH_END (config);
 	}
 
@@ -1078,7 +1057,6 @@ static void add_man_subdirs (gl_list_t list, const char *path)
 	if (subdir) {
 		newpath = xasprintf ("%.*s/man", (int) (subdir - path), path);
 		if (is_directory (newpath) == 1) {
-			insert_override_dir (list, newpath);
 			add_dir_to_list (list, newpath);
 		}
 		free (newpath);
@@ -1086,7 +1064,6 @@ static void add_man_subdirs (gl_list_t list, const char *path)
 
 	newpath = xasprintf ("%s/man", path);
 	if (is_directory (newpath) == 1) {
-		insert_override_dir (list, newpath);
 		add_dir_to_list (list, newpath);
 	}
 	free (newpath);
@@ -1095,7 +1072,6 @@ static void add_man_subdirs (gl_list_t list, const char *path)
 		newpath = xasprintf ("%.*s/share/man",
 				     (int) (subdir - path), path);
 		if (is_directory (newpath) == 1) {
-			insert_override_dir (list, newpath);
 			add_dir_to_list (list, newpath);
 		}
 		free (newpath);
@@ -1103,7 +1079,6 @@ static void add_man_subdirs (gl_list_t list, const char *path)
 
 	newpath = xasprintf ("%s/share/man", path);
 	if (is_directory (newpath) == 1) {
-		insert_override_dir (list, newpath);
 		add_dir_to_list (list, newpath);
 	}
 	free (newpath);
@@ -1199,7 +1174,9 @@ gl_list_t create_pathlist (const char *manp)
 	const struct canonicalized_path *cp;
 
 	/* Expand the manpath into a list of (path, canonicalized path)
-	 * pairs for easier handling.  add_dir_to_path_list only adds items
+	 * pairs for easier handling. For each entry, add corresponding
+	 * OVERRIDE_DIR.
+	 * add_dir_to_path_list only adds items
 	 * if they do not have the same canonicalized path as an existing
 	 * item, thereby eliminating duplicates due to symlinks.
 	 */
@@ -1208,15 +1185,25 @@ gl_list_t create_pathlist (const char *manp)
 		(GL_LINKEDHASH_LIST, canonicalized_path_equals,
 		 canonicalized_path_hash, canonicalized_path_free, false);
 	for (p = manp;; p = end + 1) {
+		char *element, *element_override;
+		ssize_t p_len;
+
 		end = strchr (p, ':');
-		if (end) {
-			char *element = xstrndup (p, end - p);
-			add_dir_to_path_list (canonicalized_list, element);
-			free (element);
-		} else {
-			add_dir_to_path_list (canonicalized_list, p);
-			break;
+		p_len = end ? end - p : (ssize_t)strlen(p);
+
+		element = xstrndup (p, p_len);
+
+		if (strlen(OVERRIDE_DIR)) {
+			element_override = xasprintf("%s/%s", element, OVERRIDE_DIR);
+			add_dir_to_path_list (canonicalized_list, element_override);
+			free (element_override);
 		}
+
+		add_dir_to_path_list (canonicalized_list, element);
+		free (element);
+
+		if (!end)
+			break;
 	}
 
 	list = new_string_list (GL_ARRAY_LIST, false);
-- 
2.26.2

